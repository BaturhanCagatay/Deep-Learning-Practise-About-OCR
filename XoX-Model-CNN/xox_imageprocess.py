# -*- coding: utf-8 -*-
"""XOX_ImageProcess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19cyxw9ULIWr03m88CJP7OReBhNgKaUSc

# Deneme 1
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.utils import to_categorical

# 1. Veri Hazırlığı
def xox_veri_hazirla(num_samples=1000):
    """
    Rastgele XOX tahtaları ve sonuçlar oluşturur.
    """
    X = np.random.randint(-1, 2, (num_samples, 3, 3, 1))  # 3x3 tahtalar
    y = []
    for tahta in X:
        # Basit bir kazanan belirleyici
        if np.any(np.sum(tahta, axis=0) == 3) or np.any(np.sum(tahta, axis=1) == 3):
            y.append(1)  # X kazandı
        elif np.any(np.sum(tahta, axis=0) == -3) or np.any(np.sum(tahta, axis=1) == -3):
            y.append(2)  # O kazandı
        elif np.trace(tahta) == 3 or np.trace(np.fliplr(tahta)) == 3:
            y.append(1)  # X kazandı
        elif np.trace(tahta) == -3 or np.trace(np.fliplr(tahta)) == -3:
            y.append(2)  # O kazandı
        else:
            y.append(0)  # Berabere
    return X, to_categorical(y, 3)

# Veriyi oluştur
X, y = xox_veri_hazirla(num_samples=100000)

# Eğitim ve test verisini ayır
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 2. Model Oluşturma
model = models.Sequential([
    layers.Conv2D(32, (2, 2), activation='relu', input_shape=(3, 3, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(3, activation='softmax')  # 3 sınıf: X kazandı, O kazandı, berabere
])

# Modeli derleme
model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# 3. Modeli Eğitme
model.fit(X_train, y_train, epochs=20, batch_size=32, validation_split=0.1)

# Modeli kaydet
model.save("xox_model.h5")

# 4. Model Yükleme ve Test Etme
from tensorflow.keras.models import load_model

# Eğitilmiş modeli yükleme
model = load_model("xox_model.h5")

# Test verisinde doğruluk
test_loss, test_acc = model.evaluate(X_test, y_test)
print(f"Test Doğruluğu: {test_acc:.2f}")

# 5. XOX Tahtası ile Tahmin Yapma
def tahmin_yap(model, tahta):
    """
    Modelin bir XOX tahtasında tahmin yapmasını sağlar.
    """
    tahta = np.array(tahta).reshape(1, 3, 3, 1)
    tahmin = model.predict(tahta)
    sonuc = np.argmax(tahmin)

    if sonuc == 0:
        return "Oyun Berabere."
    elif sonuc == 1:
        return "X Kazandı!"
    elif sonuc == 2:
        return "O Kazandı!"

# Örnek XOX tahtası
xox_tahtasi = [
    [1, 0, 0],
    [0, 1, -1],
    [-1, 0, 1]
]

# Tahmin yap
sonuc = tahmin_yap(model, xox_tahtasi)
print("Tahmin:", sonuc)

"""# Deneme 2"""

import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
import random
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from matplotlib import pyplot as plt

# Tahta durumları
EMPTY = 0
PLAYER_X = 1
PLAYER_O = -1

# Basit CNN modelini oluşturma (MaxPooling kaldırıldı)
def build_simple_cnn_model():
    model = models.Sequential([
        layers.Conv2D(32, (2, 2), activation='relu', input_shape=(3, 3, 1)),
        layers.Conv2D(64, (1, 1), activation='relu'),
        layers.Conv2D(128, (1, 1), activation='relu'),
        layers.Flatten(),
        layers.Dense(128, activation='relu'),
        layers.Dropout(0.5),
        layers.Dense(9, activation='softmax')  # 9 olasılık, 3x3 tahta
    ])
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# Veri setini oluşturma
def generate_training_data(num_samples=100000):
    X = []
    y = []
    for _ in range(num_samples):
        board = np.random.choice([EMPTY, PLAYER_X, PLAYER_O], size=(3, 3))
        valid_moves = np.argwhere(board == EMPTY)
        if len(valid_moves) > 0:
            move = random.choice(valid_moves)
            label = np.zeros(9)
            label[move[0] * 3 + move[1]] = 1
            X.append(board.reshape(3, 3, 1))  # Kanal boyutunu ekle
            y.append(label)
    return np.array(X), np.array(y)

# Eğitim verisini oluştur
X_train, y_train = generate_training_data(num_samples=500000)

# Veri artırma (augmentation)
datagen = ImageDataGenerator(
    rotation_range=15,
    width_shift_range=0.1,
    height_shift_range=0.1
)
datagen.fit(X_train)

# Modeli oluştur ve eğit
model = build_simple_cnn_model()
model.fit(datagen.flow(X_train, y_train, batch_size=32), epochs=30, verbose=1)

# Modeli kaydet
model.save("xox_model_simple_cnn.h5")

# En iyi hamleyi seçme
def en_iyi_hamle(model, tahta):
    tahta = tahta.reshape(1, 3, 3, 1)
    predictions = model.predict(tahta).reshape(3, 3)
    bos_hucreler = np.argwhere(tahta.reshape(3, 3) == EMPTY)
    en_iyi = max(bos_hucreler, key=lambda x: predictions[x[0], x[1]])
    return en_iyi

# Oyun mekaniği
def yazdir_tahta(tahta):
    semboller = {EMPTY: ".", PLAYER_X: "X", PLAYER_O: "O"}
    print("\n".join([" ".join([semboller[tahta[i][j]] for j in range(3)]) for i in range(3)]))

def kontrol_kazanan(tahta):
    for i in range(3):
        if abs(sum(tahta[i, :])) == 3: return tahta[i, 0]
        if abs(sum(tahta[:, i])) == 3: return tahta[0, i]
    if abs(tahta.trace()) == 3: return tahta[0, 0]
    if abs(np.fliplr(tahta).trace()) == 3: return tahta[0, 2]
    if not (tahta == EMPTY).any(): return 0
    return None

def oyuncu_hamlesi(tahta):
    while True:
        try:
            hamle = input("Hamleni yap (satır, sütun): ")
            satir, sutun = map(int, hamle.split(","))
            if tahta[satir, sutun] == EMPTY:
                return satir, sutun
            else:
                print("Bu hücre dolu!")
        except:
            print("Geçersiz giriş. Tekrar dene.")

def oyun():
    tahta = np.zeros((3, 3), dtype=int)
    oyuncu = PLAYER_X
    while True:
        yazdir_tahta(tahta)
        kazanan = kontrol_kazanan(tahta)
        if kazanan is not None:
            if kazanan == PLAYER_X:
                print("Tebrikler, X kazandı!")
            elif kazanan == PLAYER_O:
                print("O kazandı!")
            else:
                print("Oyun berabere!")
            break

        if oyuncu == PLAYER_X:
            print("Sıra insan oyuncuda!")
            satir, sutun = oyuncu_hamlesi(tahta)
        else:
            print("Sıra AI oyuncuda!")
            satir, sutun = en_iyi_hamle(model, tahta)

        tahta[satir, sutun] = oyuncu
        oyuncu = PLAYER_O if oyuncu == PLAYER_X else PLAYER_X

# Eğitim sonrası tahmin raporu
def performans_analizi(X_test, y_test):
    predictions = model.predict(X_test)
    y_true = y_test.argmax(axis=1)
    y_pred = predictions.argmax(axis=1)
    print(classification_report(y_true, y_pred))

# Oyun başlatma
oyun()

oyun()

"""# Deneme 3"""

import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split
from sklearn.utils import class_weight

# 1. Veri Hazırlığı
def xox_veri_hazirla(num_samples=200000):
    """
    Rastgele XOX tahtaları ve sonuçlar oluşturur.
    """
    X = np.random.randint(-1, 2, (num_samples, 3, 3, 1))  # 3x3 tahtalar
    y = []
    for tahta in X:
        # Kazanan belirleyici
        if np.any(np.sum(tahta, axis=0) == 3) or np.any(np.sum(tahta, axis=1) == 3):
            y.append(1)  # X kazandı
        elif np.any(np.sum(tahta, axis=0) == -3) or np.any(np.sum(tahta, axis=1) == -3):
            y.append(2)  # O kazandı
        elif np.trace(tahta) == 3 or np.trace(np.fliplr(tahta)) == 3:
            y.append(1)  # X kazandı
        elif np.trace(tahta) == -3 or np.trace(np.fliplr(tahta)) == -3:
            y.append(2)  # O kazandı
        else:
            y.append(0)  # Berabere

    return X, to_categorical(y, 3)

# Veriyi oluştur
X, y = xox_veri_hazirla()

# Veriyi train ve test olarak böl
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Sınıf ağırlıklarını hesapla (sınıf dengesizliği varsa düzeltmek için)
class_weights = class_weight.compute_class_weight('balanced', classes=np.arange(3), y=np.argmax(y_train, axis=1))
class_weights = {i: weight for i, weight in enumerate(class_weights)}

# 2. Model Tanımı
def xox_model():
    model = models.Sequential([
        layers.Conv2D(32, (3, 3), activation='relu', input_shape=(3, 3, 1)),
        layers.Flatten(),
        layers.Dense(64, activation='relu'),
        layers.Dense(3, activation='softmax')
    ])
    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    return model

# Modeli oluştur
model = xox_model()

# 3. Eğitim
# Erken durdurma eklendi
early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

history = model.fit(
    X_train, y_train,
    epochs=50,
    batch_size=32,
    validation_split=0.2,
    class_weight=class_weights,
    callbacks=[early_stopping]
)

# 4. Model Performansı
loss, accuracy = model.evaluate(X_test, y_test)
print(f"Test Loss: {loss:.4f}")
print(f"Test Accuracy: {accuracy:.4f}")

# Eğitim ve doğrulama eğrilerini çizmek için:
import matplotlib.pyplot as plt

def plot_history(history):
    plt.figure(figsize=(12, 4))

    # Loss grafiği
    plt.subplot(1, 2, 1)
    plt.plot(history.history['loss'], label='Eğitim Kaybı')
    plt.plot(history.history['val_loss'], label='Doğrulama Kaybı')
    plt.title('Model Kaybı')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend()

    # Doğruluk grafiği
    plt.subplot(1, 2, 2)
    plt.plot(history.history['accuracy'], label='Eğitim Doğruluğu')
    plt.plot(history.history['val_accuracy'], label='Doğrulama Doğruluğu')
    plt.title('Model Doğruluğu')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.legend()

    plt.show()

plot_history(history)

import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split
from sklearn.utils import class_weight
import random

# 1. Veri Hazırlığı
def xox_veri_hazirla(num_samples=20000, augment=True):
    """
    Rastgele XOX tahtaları ve sonuçlar oluşturur. Veri artırma için döndürme ve yansıma uygulanabilir.
    """
    X = np.random.randint(-1, 2, (num_samples, 3, 3, 1))  # 3x3 tahtalar
    y = []
    augmented_X = []
    augmented_y = []

    for tahta in X:
        # Kazanan belirleyici
        if np.any(np.sum(tahta, axis=0) == 3) or np.any(np.sum(tahta, axis=1) == 3):
            kazanan = 1  # X kazandı
        elif np.any(np.sum(tahta, axis=0) == -3) or np.any(np.sum(tahta, axis=1) == -3):
            kazanan = 2  # O kazandı
        elif np.trace(tahta) == 3 or np.trace(np.fliplr(tahta)) == 3:
            kazanan = 1  # X kazandı
        elif np.trace(tahta) == -3 or np.trace(np.fliplr(tahta)) == -3:
            kazanan = 2  # O kazandı
        else:
            kazanan = 0  # Berabere

        # Orijinal tahta ve etiketi ekle
        augmented_X.append(tahta)
        augmented_y.append(kazanan)

        if augment:
            # Tahtayı 90, 180 ve 270 derece döndür
            for i in range(1, 4):
                rotated_tahta = np.rot90(tahta, i)
                augmented_X.append(rotated_tahta)
                augmented_y.append(kazanan)

            # Yatay ve dikey yansıma
            flipped_tahta_h = np.flipud(tahta)  # Yukarı-aşağı yansıma
            flipped_tahta_v = np.fliplr(tahta)  # Sağ-sol yansıma
            augmented_X.append(flipped_tahta_h)
            augmented_y.append(kazanan)
            augmented_X.append(flipped_tahta_v)
            augmented_y.append(kazanan)

    # Augmented veriyi numpy array'e çevir
    augmented_X = np.array(augmented_X)
    augmented_y = np.array(augmented_y)

    return augmented_X, to_categorical(augmented_y, 3)

# Veriyi oluştur
X, y = xox_veri_hazirla(num_samples=100000, augment=True)

# Veriyi train ve test olarak böl
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Sınıf ağırlıklarını hesapla (sınıf dengesizliği varsa düzeltmek için)
class_weights = class_weight.compute_class_weight('balanced', classes=np.arange(3), y=np.argmax(y_train, axis=1))
class_weights = {i: weight for i, weight in enumerate(class_weights)}

# 2. Model Tanımı
def xox_model():
    model = models.Sequential([
layers.Conv2D(32, (3, 3), activation='relu', input_shape=(3, 3, 1), padding='same'),  # Padding added here
        layers.Conv2D(64, (3, 3), activation='relu', padding='same'),  # Padding added here
        layers.Flatten(),
        layers.Dense(64, activation='relu'),
        layers.Dense(3, activation='softmax')
    ])
    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    return model

# Modeli oluştur
model = xox_model()

# 3. Eğitim
# Erken durdurma eklendi
early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

history = model.fit(
    X_train, y_train,
    epochs=30,
    batch_size=32,
    validation_split=0.2,
    class_weight=class_weights,
    callbacks=[early_stopping]
)

# 4. Model Performansı
loss, accuracy = model.evaluate(X_test, y_test)
print(f"Test Loss: {loss:.4f}")
print(f"Test Accuracy: {accuracy:.4f}")

# Eğitim ve doğrulama eğrilerini çizmek için:
import matplotlib.pyplot as plt

def plot_history(history):
    plt.figure(figsize=(12, 4))

    # Loss grafiği
    plt.subplot(1, 2, 1)
    plt.plot(history.history['loss'], label='Eğitim Kaybı')
    plt.plot(history.history['val_loss'], label='Doğrulama Kaybı')
    plt.title('Model Kaybı')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend()

    # Doğruluk grafiği
    plt.subplot(1, 2, 2)
    plt.plot(history.history['accuracy'], label='Eğitim Doğruluğu')
    plt.plot(history.history['val_accuracy'], label='Doğrulama Doğruluğu')
    plt.title('Model Doğruluğu')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.legend()

    plt.show()

plot_history(history)

# Modeli kaydet
model.save("xox_model_simple_cnn.keras")

# Tahta durumları
EMPTY = 0
PLAYER_X = 1
PLAYER_O = -1

# En iyi hamleyi seçme
# En iyi hamleyi seçme
def en_iyi_hamle(model, tahta, EMPTY=0):
    """
    En iyi hamleyi tahmin et ve oyunun durumuna göre karar ver.
    """
    # Model tahmini için tahtayı yeniden şekillendir
    tahta = tahta.reshape(1, 3, 3, 1)
    predictions = model.predict(tahta)

    # Oyunun sonucunu kontrol et
    predicted_outcome = np.argmax(predictions)

    # Oyun bitmişse (kazanan belirlenmişse), hamle yapılmaz
    if predicted_outcome != 0:  # 0: Oyun devam ediyor/durum belirsiz
        return None  # Oyun bitmiş durumda

    # Tüm boş hücreleri al
    bos_hucreler = np.argwhere(tahta.reshape(3, 3) == EMPTY)

    # Her boş hücre için modelin tahmin ettiği tahtayı simüle et
    en_iyi = None
    en_yuksek_olasilik = -1

    for hucre in bos_hucreler:
        # Hücreye geçici olarak hamle yap
        yeni_tahta = tahta.reshape(3, 3).copy()
        yeni_tahta[hucre[0], hucre[1]] = 1  # Varsayalım oyuncu 'X' oynuyor (1)

        # Modelden yeni tahtanın tahminini al
        yeni_tahta_reshape = yeni_tahta.reshape(1, 3, 3, 1)
        yeni_prediction = model.predict(yeni_tahta_reshape)

        # Kazanma olasılığına göre kontrol et
        kazanma_olasiligi = yeni_prediction[0][1]  # X'in kazanma olasılığı (etiket 1)

        if kazanma_olasiligi > en_yuksek_olasilik:
            en_yuksek_olasilik = kazanma_olasiligi
            en_iyi = hucre

    return en_iyi


# Oyun mekaniği
def yazdir_tahta(tahta):
    semboller = {EMPTY: ".", PLAYER_X: "X", PLAYER_O: "O"}
    print("\n".join([" ".join([semboller[tahta[i][j]] for j in range(3)]) for i in range(3)]))

def kontrol_kazanan(tahta):
    for i in range(3):
        if abs(sum(tahta[i, :])) == 3: return tahta[i, 0]
        if abs(sum(tahta[:, i])) == 3: return tahta[0, i]
    if abs(tahta.trace()) == 3: return tahta[0, 0]
    if abs(np.fliplr(tahta).trace()) == 3: return tahta[0, 2]
    if not (tahta == EMPTY).any(): return 0
    return None

def oyuncu_hamlesi(tahta):
    while True:
        try:
            hamle = input("Hamleni yap (satır, sütun): ")
            satir, sutun = map(int, hamle.split(","))
            if tahta[satir, sutun] == EMPTY:
                return satir, sutun
            else:
                print("Bu hücre dolu!")
        except:
            print("Geçersiz giriş. Tekrar dene.")

def oyun():
    tahta = np.zeros((3, 3), dtype=int)
    oyuncu = PLAYER_X
    while True:
        yazdir_tahta(tahta)
        kazanan = kontrol_kazanan(tahta)
        if kazanan is not None:
            if kazanan == PLAYER_X:
                print("Tebrikler, X kazandı!")
            elif kazanan == PLAYER_O:
                print("O kazandı!")
            else:
                print("Oyun berabere!")
            break

        if oyuncu == PLAYER_X:
            print("Sıra insan oyuncuda!")
            satir, sutun = oyuncu_hamlesi(tahta)
        else:
            print("Sıra AI oyuncuda!")
            satir, sutun = en_iyi_hamle(model, tahta)

        tahta[satir, sutun] = oyuncu
        oyuncu = PLAYER_O if oyuncu == PLAYER_X else PLAYER_X

# Eğitim sonrası tahmin raporu
def performans_analizi(X_test, y_test):
    predictions = model.predict(X_test)
    y_true = y_test.argmax(axis=1)
    y_pred = predictions.argmax(axis=1)
    print(classification_report(y_true, y_pred))

# Oyun başlatma
oyun()

oyun()

